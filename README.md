Report:
ReversiAi class:
The ReversiAi class contains only the minimax() function.

Class Board:
The board class contains the makeMove(), evaluate(), calculate(), getLegalMoves(), and copyBoard() functions.
Details:
minimax takes as arguments a boolean variable (player) representing which player is next in line to play at that moment, an integer (depth) representing the depth of the tree for the moment minimax is called, two integers (alpha and beta) representing 'a' and 'b' for sawing the tree where needed, and finally a variable of type Board (gameBoard) representing a snapshot of the game board at some minimax call. It is a basic MiniMax class with a-b sawing.

The makeMove function takes three integers (X, Y and player) as arguments. X represents the row of the table, Y represents the column of the table, and player represents which player it is (1 for the computer and 2 for the player). What the function does is place a checker on the board if the given move is valid, otherwise it returns false.

The calculate function takes an integer variable (player) as an argument and calculates how many checkers (value) the player for whom the function was called has and returns the result.

The evaluate function returns the difference in checkers (difference in value) in the table (in favor of player 1, which is the calculator). It is practically our heuristic function.

The getLegalMoves function takes as an argument an integer variable (player) and returns a list of moves that are allowed (for the given player) on a given board.

The copyBoard function takes as an argument a two-dimensional table (currentStateOfBoard) representing a snapshot of the board and returns a clone of that board.

Mode of Operation:
Initially minimax checks if the current time minus the initial time is greater than or equal to the maximum wait time given by the user. If it is, then the flagChopChop variable becomes true and the difference in checkers (difference in value) is returned via the evaluate() function. If the level reached at the current time is greater than maxDepth (=10) then we again call evaluate() and return its result. Then we create an ArrayList moves which is of type Board and in it we pass the list of allowed moves of the current player for a snapshot of the board by calling the function getLegalMoves(). Then if the size of the moves list is equal to 0, it means that the player of the given moment has no other allowed moves so it returns 64 if the computer is playing or -64 if the player is playing. If player is true (the computer is playing) we set the variable top=0 and start successive calls to minimax from i=0 until i<moves.size() which is the size of the list of allowed moves and pass the results to the score variable. If the score variable is greater than alpha, we give alpha to the score value and set top=i. If alpha is greater than or equal to beta, then we saw (break?).  If the level (depth) is equal to 0 then we put in the best variable the best move (moves.get(top)) and then return alpha. In the same reasoning, when the player plays (player is false) an iteration is started as many times as the allowed positions of each moment (moves) and minimax is called sequentially as above and its result is put into the score variable. If the score is less than beta, then we put the score into the variable beta and continue. If alpha is greater than or equal to beta then we saw (break?). At the end of the iteration we return beta.
The makeMove() first checks if the position of the X and Y coordinate table is empty (if not it returns false). Then it sets the variable legalOnce equal to false (if it becomes true it means that there is at least one allowed position for the player at that moment). Then it starts an iteration to check all the adjacent positions of the selection we made (for i=-1,i=0, i=1 and for j=-1,j=0, j=1) for the combinations of i and j (when i=0 and j=0 is the position we selected with X and Y so we just proceed with continue;). We set the variable k=1. The while check is done so that we don't go out of bounds during our search. If the position of the table (with the combinations of X,Y,i,j and k) is empty OR if the same position is equal to the player and we haven't found an opponent somewhere in between (passedOpponent=false) then we stop the while (break; because the move would not be allowed). If the position of the table (with the combinations of X,Y,i,j and k) is equal to our player (we found our own checker) and we have found an opponent in between (passedOpponent==true) then we set true to the variable disksToFlip and exit the loop,, otherwise if the position of the table (with the combinations of X,Y,i,j and k) is equal to the adversary 

then we set passedOpponent true and k=k+1 and continue the iteration. When we exit the while, if disksToFlip has become true (we have found our own checker in a direction that interferes with opposing checkers) then we place the player checker at the position of the table with the X and Y coordinates given and then put the checkers to be switched equal to player based on X,Y,i,j,h and k. Then we set legalOnce equal to true and continue the two for loops with i and j. Outside the for loops we keep the last X and Y that called makeMove in the variables lastMovedX and lastMovedY respectively. Finally we return legalOnce.
Evaluate simply calls the calculate() function twice, once for player=1 and once for player=2 and returns the difference between them (evaluate(1) - evaluate(2)).
Calculate initializes the variable value equal to 0 and then iteratively increments the value whenever a position in the table is equal to the player of the given time the function was called. It then returns the value.
The getLegalMoves first creates a BoardList ArrayList that is of type Board and an object of type Board (the gameBoard) and passes it a copy (clone) of the game board by calling copyBoard. With one iteration we call makeMove 64 times (for all board locations) and return true we put b in the BoardList and then update the gameBoard again via copyBoard. After the iteration we return the BoardList.
The copyBoard takes a board (currentStateOfBoard) and produces an exact copy of it and passes it to board r. It then returns r.







Class Reversi_gui:
The class contains Reversi_gui(),initializeBoard(), initialState(), paintBoard(), possibleMoves(), move(), getClick() and setColor().
First in our main we create a new Reversi_gui object, gameWindow, and set our frame to be visible (gameWindow.frame.setVisible(true)) .
Reversi_gui() essentially creates our application by calling the methods initializeBoard(), initialSate(),paintBoard(), possibleMoves() and making a ReversiAiBoard object of type Board where it sets the initial state of the board (currentStateOfBoard).
The initializeBoard() creates a new JFrame named "Reversi" ,with setBounds initializes its size and where on the screen it will appear, subsequently we create a JLabel named "Computer : 2" which contains the value 2 denoting the initial birds of the computer and subsequently as the game progresses it changes according to the birds it has acquired ,accordingly we create a JLabel for the player playing doing the same things. We then create 2 TextFields which accept the values the user will write for Max depth and Max time and are initialized with the values given by the program when the game starts. Above the TextFields with 2 new JLabel we write what each is with the respective names Max depth and Max time. Finally we create a table of Jbuttons that define the game environment ,in essence 64 boxes are created on which the user can click with the help of MouseClicked and the program will recognize which box it refers to. 
The initialState() initializes the currentStateOfBoard table and puts the 4 initial checkers (2 for each player) in its center.
paintBoard() iterates over all the board positions and calls setColor() to paint each board position.
The setColor() takes as arguments two integers (x and y) representing the coordinates of a board position and another integer variable (c) representing the board value at that position. Then if c is equal to 0 (empty position) it sets that position to the color green. If c is equal to 1, then it is the checker of the computer, so it puts the color black in that position. Finally, if c is equal to 2, then it is the player's checker, so it puts the colour white in that position.
possibleMoves() creates an ArrayList of moves of type Board and fills it with the results that the function ReversiAiBoard.getLegalMoves(2) (class ReversiAi, ReversiAiBoard is the board in question and 2 stands for the player playing and not the computer), thus the player's allowed moves. Then with one iteration, it fills the positions of the board that are allowed in each case with green (more open than the board).
The getClick() takes a JButton (j) as an argument, translates it to coordinates of the table, prints a message with the coordinates given, and then calls move (sending it the x and y coordinates it got). 

Mode of Operation:
Initially Reversi_gui() calls the methods initializeBoard(), initialState(),paintBoard(), possibleMoves() and creates an object ReversiAiBoard of type Board where it puts the initial state of the board (currentStateOfBoard). After our panel is created with the appropriate buttons, the score board and of course the game board, it's the player's turn to choose which move to make. When the player makes a click on the board getClick() takes the coordinates of the board and calls move(x, y). Initially move checks if the player has 0 allowed moves. If so, then it calls initialState() and paintBoard() and returns (return;). If the position chosen by the player is not empty then it returns (return;) because this move is not allowed. If the position chosen by the player does not belong to the allowed moves given by makeMove (Board class), then it returns (return;). It then prints the scores of the two players by calling the calculate() function (Board class) for 2 and 1 respectively for each player (2 for the player, 1 for the computer). Then after accepting the position given by the player it calls paintBoard() to paint the board after the changes. It sets values to the variables startTime, maximumTimeBeforeflagCutOff (maximum time for the computer to play) and flagChopChop. Gets from the user the maximum search depth (can be changed during the game) and builds a copy board by calling copyBoard (Board class) sending the currentStateOfBoard (board state at that time). For i=0 up to the maximum depth of the tree given (and as long as flagChopChop is false), it sets our i as maxDepth and calls minimax to play the computer. If flagChopChop is false, it puts the best option given by minimax (ReversiAi.best) into the ReversiAiBoard table; otherwise it prints the maximum depth of the tree it reached. After the end of the for loop, if flagChopChop is false, then it prints the maximum depth it reached (full because it is the maximum Then it prints the scores of the two players by calling the calculate() function (Board class) for 2 and 1 respectively for each player (2 for the player, 1 for the computer) and calls paintBoard() to paint the changes and possibleMoves() to suggest the new allowed moves.



